using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace Drawing 
{
    public class ControlNet : MonoBehaviour
    {
        public Texture2D inputTexture; // The texture of the input image, that will be used as a reference for the control net
        public Texture2D outputTexture; // The texture that the output image will be drawn on
        public GameObject drawingCanvas; // The canvas that the input image is drawn on, and that will be faded out
        public GameObject outputImage; // The canvas that the output image will be drawn on, and that will be faded in
        public GameObject continueButton; // The button that will be enabled after the output image is drawn, to continue with the story
        public GameObject loadingPanel; // The panel that will be enabled while the output image is being generated by AUTOMATIC1111
        
        private float fadeDuration = 1.0f;

        // <summary>
        // Send a request to AUTOMATIC1111 to generate an image of the specified class in anime style using the control net model and display it
        // </summary>
        // <param name="className">The class of the object to be generated</param>
        public void DrawControlNet(string className)
        {
            StartCoroutine(GetControlNet(className));
        }

        // <summary>
        // Send a request to AUTOMATIC1111 to generate an image of the specified class in anime style using the control net model and display it
        // </summary>
        // <param name="className">The class of the object to be generated</param>
        private IEnumerator GetControlNet(string className)
        {
            loadingPanel.SetActive(true);
            // AUTOMATIC1111 API endpoint for generating images
            string url = "http://localhost:7860/sdapi/v1/txt2img";
            // Encode the input image to PNG format and convert it to base64, so it can be sent in the request
            byte[] inputBytes = inputTexture.EncodeToPNG();
            string inputBase64 = System.Convert.ToBase64String(inputBytes);
            Dictionary<string, object> json = new Dictionary<string, object>()
            {
                { "prompt", "a " + className + " in anime style" },
                { "negative_prompt", "deformities, distortion, out of frame, text, malformed, cropped" },
                { "steps", 20 },
                { "batch_size", 1 },
                { "cfg_scale", 7},
                // The width and height of the output image, which is half the size of the input image
                // This is done so it generates faster
                { "width", inputTexture.width / 2 },
                { "height", inputTexture.height / 2 },
                { "override_settings", new Dictionary<string, object>()
                    {
                        { "sd_model_checkpoint", "v1-5-pruned-emaonly" }
                    }
                },
                { "sampler_name", "Euler" },
                { "alwayson_scripts", new Dictionary<string, object>()
                    {
                        { "controlnet", new Dictionary<string, object>()
                            {
                                { "args", new List<object>()
                                    {
                                        new Dictionary<string, object>()
                                        {
                                            { "enabled", true },
                                            // Need to use invert module because our input image has a white background and black lines
                                            { "module", "invert (from white bg & black line)" },
                                            { "model",  "control_v11p_sd15_scribble_fp16" },
                                            { "image", inputBase64 },
                                            { "resize_mode", "Crop and Resize" },
                                            { "low_vram", false },
                                            { "guidance_start", 0.0f },
                                            { "guidance_end", 1.0f },
                                            { "control_mode", "ControlNet is more important" },
                                            { "pixel_perfect", true }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }; 
            string jsonStr = JsonConvert.SerializeObject(json);
            byte[] bytes = System.Text.Encoding.UTF8.GetBytes(jsonStr);
            using (UnityWebRequest request = new UnityWebRequest(url, "POST"))
            {
                request.uploadHandler = new UploadHandlerRaw(bytes);
                request.downloadHandler = new DownloadHandlerBuffer();
                request.SetRequestHeader("Content-Type", "application/json");
                yield return request.SendWebRequest();
                if (request.isNetworkError || request.isHttpError)
                {
                    Debug.LogError(request.error);
                }
                else
                {
                    string response = request.downloadHandler.text;
                    JObject jsonResponse = JObject.Parse(response);
                    var image = jsonResponse["images"][0].ToString();
                    // Decode the base64 image and display it
                    outputTexture.LoadImage(System.Convert.FromBase64String(image));
                    // Create a sprite from the output texture
                    Sprite sprite = Sprite.Create(outputTexture, new Rect(0, 0, outputTexture.width, outputTexture.height), new Vector2(0.5f, 0.5f));
                    SpriteRenderer inputSpriteRenderer = drawingCanvas.GetComponent<SpriteRenderer>();
                    SpriteRenderer outputSpriteRenderer = outputImage.GetComponent<SpriteRenderer>();
                    StretchSprite(outputSpriteRenderer);
                    StartCoroutine(FadeSprites(inputSpriteRenderer, outputSpriteRenderer, sprite, fadeDuration));
                }
                loadingPanel.SetActive(false);
                // Enable the continue button after the output image is drawn and allow the player to continue with the story
                continueButton.SetActive(true);
                Drawable.readyToFinish = true; 
            }
        }

        // <summary>
        // Fade out the input image and fade in the output image
        // </summary>
        // <param name="spriteRenderer1">The sprite renderer of the input image</param>
        // <param name="spriteRenderer2">The sprite renderer of the output image</param>
        // <param name="newSprite">The sprite of the output image</param>
        // <param name="duration">The duration of the fade effect</param>
        private IEnumerator FadeSprites(SpriteRenderer spriteRenderer1, SpriteRenderer spriteRenderer2, Sprite newSprite, float duration)
        {
            spriteRenderer2.sprite = newSprite;
            spriteRenderer2.color = new Color(spriteRenderer2.color.r, spriteRenderer2.color.g, spriteRenderer2.color.b, 0f);

            float elapsedTime = 0f;

            while (elapsedTime < duration)
            {
                elapsedTime += Time.deltaTime;
                float alpha1 = Mathf.Lerp(1f, 0f, elapsedTime / duration);
                float alpha2 = Mathf.Lerp(0f, 1f, elapsedTime / duration);
                spriteRenderer1.color = new Color(spriteRenderer1.color.r, spriteRenderer1.color.g, spriteRenderer1.color.b, alpha1);
                spriteRenderer2.color = new Color(spriteRenderer2.color.r, spriteRenderer2.color.g, spriteRenderer2.color.b, alpha2);
                yield return null;
            }

            spriteRenderer1.enabled = false;
            spriteRenderer2.color = new Color(spriteRenderer2.color.r, spriteRenderer2.color.g, spriteRenderer2.color.b, 1f);
        }

        // <summary>
        // Stretch the sprite to fit the output image
        // </summary>
        // <param name="spriteRenderer">The sprite renderer of the output image</param>
        public void StretchSprite(SpriteRenderer spriteRenderer)
        {
            if (spriteRenderer != null)
            {
                float xScale = (float)inputTexture.width / (float)outputTexture.width;
                float yScale = (float)inputTexture.height / (float)outputTexture.height;
                spriteRenderer.transform.localScale = new Vector3(xScale, yScale, 1.0f);
            }
        }

        // <summary>
        // Reset the control net to its initial state
        // </summary>
        public void Reset() 
        {
            continueButton.SetActive(false);
            loadingPanel.SetActive(false);
            SpriteRenderer inputSpriteRenderer = drawingCanvas.GetComponent<SpriteRenderer>();
            SpriteRenderer outputSpriteRenderer = outputImage.GetComponent<SpriteRenderer>();
            inputSpriteRenderer.enabled = true;
            inputSpriteRenderer.color = new Color(inputSpriteRenderer.color.r, inputSpriteRenderer.color.g, inputSpriteRenderer.color.b, 1f);
            outputSpriteRenderer.sprite = null;
        }
    }
}